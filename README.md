Our high level approach was to start by using and reading the starter code. In the send file at the global level we keep a list of dictionaries that contain the packet and the time it was sent. To deal with duplicates we start off by trying to send the packet and wait for the ack from the receiver. Once we get this ack we then call our duplicate method, this method sees if any of the acks we logged before are trying to be sent again. In the receive file we kept a list of the sequence numbers and data we received and once we got a packet we checked to see if we say this before with our other duplicate method. This method acted the same way the send duplicate method acted but just checked the data and sequence number to see if we already saw it. One challenge we had was realizing what fields determined a duplicate.  

We dealt with dropped packets in the send file. We waited for the recv call and changed the timeout to a quarter of a second. We then wrapped this recv call in a try except and waited for the receive to send us an ack. If we did not get an ack in a quarter of a second we then sent the same packet again until we did. We did this by try except loop that kept running until we recieved the result from the recv file. It kept running because it was in an infinite loop, the try portion tried to recieve the message, the except portion resent the message. This was because if you were in the except portion that meant you got a timeout error and did not get the ack before it timed out at .25 seconds and then a continue command to continue running the loop. Lastly there was an else block that would write a log message and break out of the loop because if you were here that meant you got a result. One challenge we faced was initally to resend a packet we called send packet, but since that was reading from stdin we should not have called it again. To solve this we saved our most current packet and directly sent it with the sendto call. Another challenge was realizing we could drop the last packet and adding code to support that. This also helped us deal with delays because if the send would timeout we would just resend the packet.

We never had a problem with reorder using the starter code therefore left that as is. The way we knew this was we looked at the sequence numbers of the packets and they were in the correct order. In addition, to configuring the netsim to reorder 99 percent of the packets and it passed.

We tested our code through reading the log statements that are still in our code as well as manipulating netsim and run. Lastly, running the test script provided.
 
